// https://cargurus.atlassian.net/browse/CRM-5092
// https://cargurus.atlassian.net/browse/CRM-5021
// methods to take a set of account ids, generate current feature maps, and compare with existing data on cg
// create up feature mismatch records if mismatch detected
// test coverage in CG_FeatureFramework_Test
public class CG_AccountFeatureComparison {
    
    // main method used by batch class, processes comparisons for supplied account ids
    public static void processFeatureComparison(Set<Id> accountIds) {

        // generate feature maps based on account statuses / cpq subscriptions / overrides
        Map<Id,CG_AccountFeatureMap> accountFeaturesMap = 
            CG_AccountFeatureMapHelper.generateAccountFeaturesMap(accountIds);

        // pull feature statuses and metadata from cg
        Map<Id,Map<Integer,Map<Integer,CG_AccountFeature>>> accountSPFeatureMap = 
            CG_FeatureIntegrationHelper.getCGFeaturesForAccountIds(accountIds);

        // setup map of service provider record id to list of feature mismatch records
        Map<Id,List<CG_Feature_Mismatch__c>> spFeatureMismatchMap = new Map<Id,List<CG_Feature_Mismatch__c>>();

        // loop through accounts
        for (Id accountId : accountFeaturesMap.keySet()) {
            CG_AccountFeatureMap accountFeatureMap = accountFeaturesMap.get(accountId);
            Account a = accountFeatureMap.afAccount;
            List<CG_AccountFeature> accountFeatures = accountFeatureMap.getSortedCurrentFeatureList();
            Map<Integer,Map<Integer,CG_AccountFeature>> spIdFeatureMap = accountSPFeatureMap.get(accountId);

            // for each service provider references in cg data, find matching service provider record
            for (Integer spId : spIdFeatureMap.keySet()) {
                Id spRecordId = getMatchingSPRecordId(a.Service_Provider__r, spId);

                // if service provider record found, set up list of feature mismatches and add to map
                if (spRecordId != null) {
                    spFeatureMismatchMap.put(spRecordId, 
                        getFeatureMismatches(accountFeatures, spIdFeatureMap.get(spId)));
                }
            }
        }

        List<CG_Feature_Mismatch__c> featureMismatchUpserts = new List<CG_Feature_Mismatch__c>();
        List<CG_Feature_Mismatch__c> featureMismatchDeletes = new List<CG_Feature_Mismatch__c>();

        // loop through service providers referenced in map, including related existing mismatch records
        for (Service_Provider__c sp : [SELECT Id, Service_Provider_Id__c, Account__c, 
                    (SELECT Id, CG_Feature_Id__c FROM CG_Feature_Mismatches__r) 
                FROM Service_Provider__c WHERE Id IN : spFeatureMismatchMap.keySet()]) {
            
            Id spRecordId = sp.Id;
            Id accountId = sp.Account__c;

            // set up map of existing mismatch records
            Map<Id,CG_Feature_Mismatch__c> existingMismatches = 
                new Map<Id,CG_Feature_Mismatch__c>(sp.CG_Feature_Mismatches__r);

            // loop through mismatch records generated by comparison process for this sp
            for (CG_Feature_Mismatch__c cgfm : spFeatureMismatchMap.get(spRecordId)) {
                Id cgfmId;

                // if existing mismatch for this feature, get the id to update and remove from existing map
                for (CG_Feature_Mismatch__c existingMismatch : existingMismatches.values()) {
                    if (existingMismatch.CG_Feature_Id__c == cgfm.CG_Feature_Id__c) {
                        cgfmId = existingMismatch.Id;
                        existingMismatches.remove(cgfmId);
                    }
                }
                
                // if existing record id found, set on record to upsert, otherwise populate account and sp record ids
                // note - account and sp record ids are not writable on existing records, as they are master/detail
                if (cgfmId != null) {
                    cgfm.Id = cgfmId;
                } else {
                    cgfm.Service_Provider__c = spRecordId;
                    cgfm.Account__c = accountId;
                }

                // set up record name and add to upsert list
                cgfm.Name = sp.Service_Provider_Id__c+' - '+cgfm.CG_Feature_Id__c+' - '+cgfm.CG_Feature_Name__c;
                cgfm.Name = cgfm.Name.left(80);
                featureMismatchUpserts.add(cgfm);
            }

            // add to delete list any existing mismatch records that have no corresponding detected mismatch
            for (CG_Feature_Mismatch__c existingMismatch : existingMismatches.values()) {
                featureMismatchDeletes.add(existingMismatch);
            }
        }

        if (!featureMismatchUpserts.isEmpty()) {
            upsert featureMismatchUpserts;
        }

        if (!featureMismatchDeletes.isEmpty()) {
            delete featureMismatchDeletes;
        }
    }

    // find matching service provider record in list for supplied sp id
    static Id getMatchingSPRecordId(List<Service_Provider__c> spList, Integer spId) {
        for (Service_Provider__c sp : spList) {
            if (Integer.valueOf(sp.Service_Provider_Id__c) == spId) {
                return sp.Id;
            }
        }
        return null;
    }

    // given list of current feature map from sf and map of sp features from cg, find mismatches and set up records
    static List<CG_Feature_Mismatch__c> getFeatureMismatches(List<CG_AccountFeature> sfFeatureList, 
            Map<Integer,CG_AccountFeature> cgFeatureMap) {
        
        List<CG_Feature_Mismatch__c> returnList = new List<CG_Feature_Mismatch__c>();
        
        // loop through list of account features from sf
        for (CG_AccountFeature sfFeature : sfFeatureList) {
            Integer fId = sfFeature.cgFeatureId;
            CG_AccountFeature cgFeature = cgFeatureMap.get(fId);

            if (cgFeature == null) {
                continue;
            }

            String sfStatus = sfFeature.featureStatus;
            String cgStatus = cgFeature.featureStatus;

            // if both sf and cg agree that this feature is inactive, skip checking metadata
            if (sfStatus == 'I' && cgStatus == 'I') {
                continue;
            }

            Boolean statusMismatch = sfStatus != cgStatus;
            
            // get sf/cg metadata strings with no white space
            String sfFeaturemdString = String.isBlank(sfFeature.featureMetadataString) ? 
                null : sfFeature.featureMetadataString.deleteWhitespace();
            String cgFeaturemdString = String.isBlank(cgFeature.featureMetadataString) ? 
                null : cgFeature.featureMetadataString.deleteWhitespace();

            Boolean mdMismatch = false;

            // check if sf/cg metadata strings match, and if not setup maps and check if values match
            // we do this because the values may be in a different order, causing a string mismatch
            if (sfFeaturemdString != cgFeaturemdString) {
                if (sfFeaturemdString == null || cgFeaturemdString == null 
                        || !JSON.deserializeUntyped(sfFeaturemdString).equals(
                                JSON.deserializeUntyped(cgFeaturemdString)
                            )) {
                    mdMismatch = true;
                }
            }

            // if both status and metadata match, move on
            if (!statusMismatch && !mdMismatch) {
                continue;
            }

            // we have a mismatch, so set up a record
            returnList.add(
                new CG_Feature_Mismatch__c(
                    CG_Feature_Id__c = fId,
                    CG_Feature_Name__c = sfFeature.featureName,
                    Status_SF__c = sfFeature.featureStatus,
                    Status_CG__c = cgFeature.featureStatus,
                    Metadata_SF__c = sfFeaturemdString,
                    Metadata_CG__c = cgFeaturemdString,
                    CG_Last_Modified__c = cgFeature.cgLastUpdatedDatetime,
                    CG_Last_Modified_By__c = cgFeature.cgLastUpdatedBy
                )
            );
        }

        return returnList;
    }

}